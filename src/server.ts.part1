import express from 'express';
import cors from 'cors';
import { databaseService } from './services/DatabaseService';
import { InvestigationService } from './services/InvestigationService';
import { HypothesisService } from './services/HypothesisService';
import { EvidenceLinkService } from './services/EvidenceLinkService';
import { NoteService } from './services/NoteService';
import { TaskService } from './services/TaskService';
import { SearchFilters, SortOption } from './types';

const app = express();
const PORT = process.env.API_PORT || 3012;

// Middleware
app.use(cors());
app.use(express.json());

// Initialize services
const db = databaseService.getDatabase();
const investigationService = new InvestigationService(db);
const hypothesisService = new HypothesisService(db);
const evidenceLinkService = new EvidenceLinkService(db);
const noteService = new NoteService(db);
const taskService = new TaskService(db);

// Health check
app.get('/api/health', (_req, res) => {
  res.json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString(),
    database: databaseService.isInitialized() ? 'connected' : 'not_initialized'
  });
});

// Get paginated entities
app.get('/api/entities', async (req, res) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 24;
    const search = req.query.search as string;
    const role = req.query.role as string;
    const likelihood = req.query.likelihood as string;
    const sortBy = req.query.sortBy as string;
    const sortOrder = req.query.sortOrder as 'asc' | 'desc';
    const minRedFlagIndex = req.query.minRedFlagIndex ? parseInt(req.query.minRedFlagIndex as string) : undefined;
    const maxRedFlagIndex = req.query.maxRedFlagIndex ? parseInt(req.query.maxRedFlagIndex as string) : undefined;

    const filters: SearchFilters = {
      likelihood: 'all',
      role: 'all',
      status: 'all',
      minMentions: 0
    };
    if (search) filters.searchTerm = search;
    if (role) filters.evidenceTypes = [role];
    if (likelihood) filters.likelihoodScore = [likelihood as 'HIGH' | 'MEDIUM' | 'LOW'];
    if (sortBy) filters.sortBy = sortBy as any;
    if (sortOrder) filters.sortOrder = sortOrder;
    if (minRedFlagIndex !== undefined) filters.minRedFlagIndex = minRedFlagIndex;
    if (maxRedFlagIndex !== undefined) filters.maxRedFlagIndex = maxRedFlagIndex;

    const result = await databaseService.getEntities(page, limit, filters, sortBy as SortOption);

    // Transform the result to match the expected format
    const transformedData = result.entities.map((entity: any) => ({
      id: entity.id,
      name: entity.fullName,
      fullName: entity.fullName,
      entity_type: entity.entityType,
      title: entity.title || entity.primaryRole,
      role: entity.role || entity.primaryRole,
      primaryRole: entity.primaryRole,
      secondaryRoles: entity.secondaryRoles || [],
      title_variants: entity.titleVariants,
      mentions: entity.mentions,
      files: entity.documentCount || (entity.fileReferences ? entity.fileReferences.length : 0),
      contexts: entity.contexts || [],
      evidence_types: entity.secondaryRoles || [],
      spicy_passages: entity.spicyPassages || [],
      likelihood_score: entity.likelihoodLevel,
      red_flag_rating: entity.red_flag_rating || entity.redFlagRating || 0,
      connectionsToEpstein: entity.connectionsSummary || ''
    }));

    res.json({
      data: transformedData,
      total: result.total,
      page: page,
      pageSize: limit,
      totalPages: Math.ceil(result.total / limit)
    });
  } catch (error) {
    console.error('Error fetching entities:', error);
    res.status(500).json({ 
      error: 'Failed to fetch entities',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get single entity by ID
app.get('/api/entities/:id', async (req, res) => {
  try {
    const entityId = req.params.id;
    const entity = await databaseService.getEntityById(entityId);
    
    if (!entity) {
      return res.status(404).json({ error: 'Entity not found' });
    }

    // Transform entity to match expected API format
    const transformedEntity = {
      id: entity.id,
      name: entity.fullName,
      fullName: entity.fullName,
      entity_type: entity.entityType,
      title: entity.title || entity.primaryRole,
      role: entity.role || entity.primaryRole,
      primaryRole: entity.primaryRole,
      secondaryRoles: entity.secondaryRoles || [],
      title_variants: entity.titleVariants,
      mentions: entity.mentions,
      files: entity.fileReferences ? entity.fileReferences.length : 0,
      contexts: entity.contexts || [],
      evidence_types: entity.secondaryRoles || [],
      spicy_passages: entity.spicyPassages || [],
      likelihood_score: entity.likelihoodLevel,
      red_flag_rating: entity.red_flag_rating || entity.redFlagRating || 0,
      connectionsToEpstein: entity.connectionsSummary || '',
      fileReferences: entity.fileReferences || []
    };

    res.json(transformedEntity);
  } catch (error) {
    console.error('Error fetching entity:', error);
    res.status(500).json({ 
      error: 'Failed to fetch entity',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get documents for an entity
app.get('/api/entities/:id/documents', async (req, res) => {
  try {
    const documents = await databaseService.getEntityDocuments(req.params.id);
    res.json(documents);
  } catch (error) {
    console.error('Error fetching entity documents:', error);
    res.status(500).json({ 
      error: 'Failed to fetch entity documents',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get documents for a specific entity
app.get('/api/entities/:id/documents', async (req, res) => {
  try {
    const entityId = req.params.id;
    const entity = await databaseService.getEntityById(entityId);
    
    if (!entity) {
      return res.status(404).json({ error: 'Entity not found' });
    }

    // Return the file references as documents
    const documents = entity.fileReferences || [];
    
    res.json(documents);
  } catch (error) {
    console.error('Error fetching entity documents:', error);
    res.status(500).json({ 
      error: 'Failed to fetch entity documents',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get paginated documents
app.get('/api/documents', async (req, res) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 50;
    const sortBy = req.query.sortBy as string;
    
    const filters: any = {};
    if (req.query.fileType) {
      filters.fileType = (req.query.fileType as string).split(',');
    }
    if (req.query.minRedFlag) {
      filters.redFlagLevel = { ...filters.redFlagLevel, min: parseInt(req.query.minRedFlag as string) };
    }
    if (req.query.maxRedFlag) {
      filters.redFlagLevel = { ...filters.redFlagLevel, max: parseInt(req.query.maxRedFlag as string) };
    }

    const result = await databaseService.getDocuments(page, limit, filters, sortBy);
    
    res.json({
      data: result.documents,
      total: result.total,
      page,
      pageSize: limit,
      totalPages: Math.ceil(result.total / limit)
    });
  } catch (error) {
    console.error('Error fetching documents:', error);
    res.status(500).json({ 
      error: 'Failed to fetch documents',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get single document by ID
app.get('/api/documents/:id', async (req, res) => {
  try {
    const documentId = req.params.id;
    const document = await databaseService.getDocumentById(documentId);
    
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }

    res.json(document);
  } catch (error) {
    console.error('Error fetching document:', error);
    res.status(500).json({ 
      error: 'Failed to fetch document',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Search entities and documents
app.get('/api/search', async (req, res) => {
  try {
    const query = req.query.q as string;
    const limit = parseInt(req.query.limit as string) || 50;

    if (!query) {
      return res.status(400).json({ error: 'Search query is required' });
    }

    const result = await databaseService.search(query, limit);

    // Transform entities to match expected API format
    const transformedEntities = result.entities.map((entity: any) => ({
      id: entity.id,
      name: entity.fullName,
      fullName: entity.fullName,
      entity_type: entity.entityType,
      title: entity.title || entity.primaryRole,
      role: entity.role || entity.primaryRole,
      primaryRole: entity.primaryRole,
      secondaryRoles: entity.secondaryRoles || [],
      title_variants: entity.titleVariants,
      mentions: entity.mentions,
      files: entity.fileReferences ? entity.fileReferences.length : 0,
      contexts: entity.contexts || [],
      evidence_types: entity.secondaryRoles || [],
      spicy_passages: entity.spicyPassages || [],
      likelihood_score: entity.likelihoodLevel,
      red_flag_rating: entity.red_flag_rating || entity.redFlagRating || 0,
      connectionsToEpstein: entity.connectionsSummary || ''
    }));

    // Transform documents to match expected API format
    const transformedDocuments = result.documents.map((doc: any) => ({
      id: doc.id,
      fileName: doc.fileName,
      filePath: doc.filePath,
      fileType: doc.fileType,
      evidenceType: doc.evidenceType,
      contentPreview: doc.snippet || doc.contentPreview,
      mentionsCount: doc.mentionsCount,
      createdAt: doc.createdAt
    }));

    res.json({
      entities: transformedEntities,
      documents: transformedDocuments
    });
  } catch (error) {
    console.error('Error searching:', error);
    res.status(500).json({ 
      error: 'Failed to perform search',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get database statistics
app.get('/api/stats', async (_req, res) => {
  try {
    const stats = await databaseService.getStatistics();
    res.json(stats);
  } catch (error) {
    console.error('Error fetching statistics:', error);
    res.status(500).json({ 
      error: 'Failed to fetch statistics',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Black Book endpoint
app.get('/api/black-book', async (req, res) => {
  try {
    const entries = databaseService.getBlackBookEntries();
    res.json(entries);
  } catch (error) {
    console.error('Error fetching Black Book:', error);
    res.status(500).json({ error: 'Failed to fetch Black Book data' });
  }
});

// Black Book review endpoints
app.get('/api/black-book/review', async (req, res) => {
  try {
    const entries = databaseService.getBlackBookReviewEntries();
    const stats = databaseService.getBlackBookReviewStats();
    
    res.json({ entries, stats });
  } catch (error) {
    console.error('Error fetching review entries:', error);
    res.status(500).json({ error: 'Failed to fetch review entries' });
  }
});

app.post('/api/black-book/review/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { correctedName, action } = req.body;
    
    const result = databaseService.updateBlackBookReview(
      parseInt(id), 
      correctedName, 
      action
    );
    
    res.json(result);
  } catch (error) {
    console.error('Error saving review:', error);
    res.status(500).json({ error: 'Failed to save review' });
  }
});

// Get document pages
app.get('/api/documents/:id/pages', async (req, res) => {
  try {
    const result = await databaseService.getDocumentPages(req.params.id);
    res.json(result);
  } catch (error) {
    console.error('Error fetching analytics:', error);
    res.status(500).json({ error: 'Failed to fetch analytics data' });
  }
});

// Get media items for an entity
app.get('/api/entities/:id/media', async (req, res) => {
  try {
    const entityId = req.params.id;
    const mediaItems = await databaseService.getMediaItems(entityId);
    res.json(mediaItems);
  } catch (error) {
    console.error('Error fetching media items:', error);
    res.status(500).json({ 
      error: 'Failed to fetch media items',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get paginated media items
app.get('/api/media', async (req, res) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 24;
    
    const filters: { entityId?: string, verificationStatus?: string, minRedFlagRating?: number } = {};
    if (req.query.entityId) filters.entityId = req.query.entityId as string;
    if (req.query.verificationStatus) filters.verificationStatus = req.query.verificationStatus as string;
    if (req.query.minRedFlagRating) filters.minRedFlagRating = parseInt(req.query.minRedFlagRating as string);
    
    const result = await databaseService.getMediaItemsPaginated(page, limit, filters);
    
    res.json({
      data: result.mediaItems,
      total: result.total,
      page,
      pageSize: limit,
      totalPages: Math.ceil(result.total / limit)
    });
  } catch (error) {
    console.error('Error fetching media items:', error);
    res.status(500).json({ 
      error: 'Failed to fetch media items',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get timeline events
app.get('/api/timeline', async (req, res) => {
  try {
    const events = await databaseService.getTimelineEvents();
    res.json(events);
  } catch (error) {
    console.error('Error fetching timeline events:', error);
    res.status(500).json({ 
      error: 'Failed to fetch timeline events',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Get all articles
app.get('/api/articles', async (req, res) => {
  try {
    const articles = await databaseService.getArticles();
    res.json(articles);
  } catch (error) {
    console.error('Error fetching articles:', error);
    res.status(500).json({ 
      error: 'Failed to fetch articles',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// ============================================
// Investigation API Endpoints
// ============================================

// GET /api/investigations - List all investigations
app.get('/api/investigations', async (req, res) => {
  try {
    const { status, ownerId, page, limit } = req.query;
    
    const result = await investigationService.getInvestigations({
      status: status as string,
      ownerId: ownerId as string,
      page: page ? parseInt(page as string) : undefined,
      limit: limit ? parseInt(limit as string) : undefined
    });
    
    res.json(result);
  } catch (error) {
    console.error('Error fetching investigations:', error);
    res.status(500).json({ 
      error: 'Failed to fetch investigations',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// POST /api/investigations - Create new investigation
app.post('/api/investigations', async (req, res) => {
  try {
    const { title, description, ownerId, scope, collaboratorIds } = req.body;
    
    if (!title || !ownerId) {
      return res.status(400).json({ 
        error: 'Validation failed',
        details: 'title and ownerId are required' 
      });
    }
    
    const investigation = await investigationService.createInvestigation({
      title,
      description,
      ownerId,
      scope,
      collaboratorIds
    });
    
    res.status(201).json(investigation);
  } catch (error) {
    console.error('Error creating investigation:', error);
    res.status(500).json({ 
      error: 'Failed to create investigation',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// GET /api/investigations/:id - Get investigation by ID
app.get('/api/investigations/:id', async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    
    if (isNaN(id)) {
      return res.status(400).json({ error: 'Invalid investigation ID' });
    }
    
    const investigation = await investigationService.getInvestigationById(id);
    
    if (!investigation) {
      return res.status(404).json({ error: 'Investigation not found' });
    }
    
    res.json(investigation);
  } catch (error) {
    console.error('Error fetching investigation:', error);
    res.status(500).json({ 
      error: 'Failed to fetch investigation',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// PATCH /api/investigations/:id - Update investigation
app.patch('/api/investigations/:id', async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    
    if (isNaN(id)) {
      return res.status(400).json({ error: 'Invalid investigation ID' });
    }
    
    const { title, description, scope, status, collaboratorIds } = req.body;
    
    const investigation = await investigationService.updateInvestigation(id, {
      title,
      description,
      scope,
      status,
      collaboratorIds
    });
    
    if (!investigation) {
      return res.status(404).json({ error: 'Investigation not found' });
    }
    
    res.json(investigation);
  } catch (error) {
    console.error('Error updating investigation:', error);
    res.status(500).json({ 
      error: 'Failed to update investigation',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// DELETE /api/investigations/:id - Delete investigation
app.delete('/api/investigations/:id', async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    
    if (isNaN(id)) {
      return res.status(400).json({ error: 'Invalid investigation ID' });
    }
    
    const deleted = await investigationService.deleteInvestigation(id);
    
    if (!deleted) {
      return res.status(404).json({ error: 'Investigation not found' });
    }
    
    res.status(204).send();
  } catch (error) {
    console.error('Error deleting investigation:', error);
    res.status(500).json({ 
      error: 'Failed to delete investigation',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});
