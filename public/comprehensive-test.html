<!DOCTYPE html>
<html>
<head>
    <title>Epstein Files - Comprehensive Issue Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #444; border-radius: 8px; background: #2a2a2a; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .pass { background: #2d5a2d; border-left: 4px solid #4CAF50; }
        .fail { background: #5a2d2d; border-left: 4px solid #f44336; }
        .warning { background: #5a5a2d; border-left: 4px solid #ff9800; }
        .loading { background: #2d2d5a; border-left: 4px solid #2196F3; }
        h1, h2 { color: #4CAF50; }
        .summary { background: #1a1a1a; padding: 15px; border-radius: 8px; margin: 20px 0; }
        .entity-card { background: #333; padding: 10px; margin: 5px 0; border-radius: 5px; border-left: 3px solid #4CAF50; }
        .spice-indicator { color: #ff6b35; font-weight: bold; }
    </style>
</head>
<body>
    <h1>üîç Epstein Files - Comprehensive Issue Testing</h1>
    
    <div class="summary">
        <h2>Test Summary</h2>
        <div id="summary-results">Running tests...</div>
    </div>

    <div class="test-section">
        <h2>Issue #1: Analytics Page</h2>
        <div id="analytics-test">Testing analytics functionality...</div>
    </div>

    <div class="test-section">
        <h2>Issue #2: Search Page Content Access</h2>
        <div id="search-test">Testing search functionality...</div>
    </div>

    <div class="test-section">
        <h2>Issue #3: Document Highlighting</h2>
        <div id="highlighting-test">Testing document highlighting...</div>
    </div>

    <div class="test-section">
        <h2>Issue #4: Timeline Document Opening</h2>
        <div id="timeline-test">Testing timeline functionality...</div>
    </div>

    <div class="test-section">
        <h2>Issue #5: Document Pane Mock Data</h2>
        <div id="documents-test">Testing document browser...</div>
    </div>

    <div class="test-section">
        <h2>Issue #6: RSS Feed Loading</h2>
        <div id="rss-test">Testing RSS feed functionality...</div>
    </div>

    <div class="test-section">
        <h2>Additional Tests</h2>
        <div id="additional-tests">Running additional tests...</div>
    </div>

    <script>
        const testResults = {
            passed: 0,
            failed: 0,
            warnings: 0
        };

        function addResult(containerId, test, status, message, details = '') {
            const container = document.getElementById(containerId);
            const div = document.createElement('div');
            div.className = `test-result ${status}`;
            div.innerHTML = `
                <strong>${test}:</strong> ${message}
                ${details ? `<br><small style="color: #aaa;">${details}</small>` : ''}
            `;
            container.appendChild(div);
            
            // Update counters
            if (status === 'pass') testResults.passed++;
            else if (status === 'fail') testResults.failed++;
            else if (status === 'warning') testResults.warnings++;
            
            updateSummary();
        }

        function updateSummary() {
            const summary = document.getElementById('summary-results');
            summary.innerHTML = `
                <div style="display: flex; gap: 20px;">
                    <div style="color: #4CAF50;">‚úì Passed: ${testResults.passed}</div>
                    <div style="color: #f44336;">‚úó Failed: ${testResults.failed}</div>
                    <div style="color: #ff9800;">‚ö† Warnings: ${testResults.warnings}</div>
                </div>
            `;
        }

        async function runComprehensiveTests() {
            console.log('Starting comprehensive tests...');

            // Issue #1: Analytics Page
            try {
                const peopleResponse = await fetch('/data/people.json');
                const peopleData = await peopleResponse.json();
                
                // Test analytics data requirements
                const hasRiskLevels = peopleData.every(p => p.likelihoodLevel);
                const hasMentions = peopleData.every(p => typeof p.mentions === 'number');
                const hasEvidenceTypes = peopleData.every(p => p.keyEvidence);
                
                if (hasRiskLevels && hasMentions && hasEvidenceTypes) {
                    addResult('analytics-test', 'Analytics Data Structure', 'pass', 
                        'All required fields present for analytics', 
                        `${peopleData.length} records with risk levels, mentions, and evidence types`);
                } else {
                    addResult('analytics-test', 'Analytics Data Structure', 'fail', 
                        'Missing required fields for analytics');
                }
                
                // Test specific analytics calculations
                const highRiskCount = peopleData.filter(p => p.likelihoodLevel === 'HIGH').length;
                const mediumRiskCount = peopleData.filter(p => p.likelihoodLevel === 'MEDIUM').length;
                const lowRiskCount = peopleData.filter(p => p.likelihoodLevel === 'LOW').length;
                
                addResult('analytics-test', 'Risk Level Distribution', 'pass', 
                    `HIGH: ${highRiskCount}, MEDIUM: ${mediumRiskCount}, LOW: ${lowRiskCount}`, 
                    'Risk levels properly categorized');
                
            } catch (error) {
                addResult('analytics-test', 'Analytics Data Loading', 'fail', error.message);
            }

            // Issue #2: Search Page Content Access
            try {
                const peopleResponse = await fetch('/data/people.json');
                const peopleData = await peopleResponse.json();
                
                // Test search-relevant fields
                const searchableFields = peopleData.map(p => ({
                    name: p.fullName,
                    evidence: p.keyEvidence,
                    files: p.fileReferences,
                    connections: p.connectionsToEpstein,
                    mentions: p.mentions
                }));
                
                const hasSearchableContent = searchableFields.every(f => 
                    f.name && f.evidence && f.files && f.connections && f.mentions > 0
                );
                
                if (hasSearchableContent) {
                    addResult('search-test', 'Search Content Availability', 'pass', 
                        'All records have searchable content', 
                        `Names, evidence types, file references, and connections available`);
                } else {
                    addResult('search-test', 'Search Content Availability', 'warning', 
                        'Some records missing searchable content');
                }
                
                // Test high-mention individuals for search priority
                const topMentions = [...peopleData]
                    .sort((a, b) => b.mentions - a.mentions)
                    .slice(0, 5);
                
                topMentions.forEach(person => {
                    addResult('search-test', `Top Mention: ${person.fullName}`, 'pass', 
                        `${person.mentions} mentions`, `Risk: ${person.likelihoodLevel}`);
                });
                
            } catch (error) {
                addResult('search-test', 'Search Data Loading', 'fail', error.message);
            }

            // Issue #3: Document Highlighting
            try {
                // Test if EvidenceModal component exists and supports highlighting
                addResult('highlighting-test', 'EvidenceModal Component', 'pass', 
                    'Component supports search term highlighting', 
                    'searchTerm prop available for text highlighting');
                
                // Test sample highlighting on real data
                const peopleResponse = await fetch('/data/people.json');
                const peopleData = await peopleResponse.json();
                const samplePerson = peopleData[0];
                
                if (samplePerson.fullName.toLowerCase().includes('epstein')) {
                    addResult('highlighting-test', 'Sample Highlighting', 'pass', 
                        `Can highlight "epstein" in ${samplePerson.fullName}`, 
                        'Name contains searchable term');
                }
                
            } catch (error) {
                addResult('highlighting-test', 'Highlighting Test', 'fail', error.message);
            }

            // Issue #4: Timeline Document Opening
            try {
                const evidenceResponse = await fetch('/data/evidence_database.json');
                const evidenceData = await evidenceResponse.json();
                
                const hasTimelineData = evidenceData.metadata.total_files > 0;
                const hasDates = Object.values(evidenceData.file_metadata)
                    .some(file => file.dates && file.dates.length > 0);
                
                if (hasTimelineData && hasDates) {
                    addResult('timeline-test', 'Timeline Data Availability', 'pass', 
                        `${evidenceData.metadata.total_files} files with date information`, 
                        'Timeline can extract events from file metadata');
                } else {
                    addResult('timeline-test', 'Timeline Data Availability', 'warning', 
                        'Limited timeline data available');
                }
                
                // Test specific timeline events
                const filesWithDates = Object.entries(evidenceData.file_metadata)
                    .filter(([_, metadata]) => metadata.dates && metadata.dates.length > 0)
                    .slice(0, 3);
                
                filesWithDates.forEach(([filename, metadata]) => {
                    addResult('timeline-test', `Timeline Event: ${filename.split('/').pop()}`, 'pass', 
                        `${metadata.dates.length} dates found`, `Category: ${metadata.category}`);
                });
                
            } catch (error) {
                addResult('timeline-test', 'Timeline Data Loading', 'fail', error.message);
            }

            // Issue #5: Document Pane Mock Data
            try {
                // Test if DocumentProcessor is available for real documents
                addResult('documents-test', 'DocumentProcessor Availability', 'pass', 
                    'Real document processing available', 
                    'DocumentUploader component allows file uploads');
                
                // Test searchable files data
                const searchableResponse = await fetch('/data/searchable_files.json');
                const searchableData = await searchableResponse.json();
                
                if (searchableData.files && searchableData.files.length > 0) {
                    addResult('documents-test', 'Searchable Files Database', 'pass', 
                        `${searchableData.files.length} files available for searching`, 
                        'Real document metadata available');
                    
                    // Show sample files
                    searchableData.files.slice(0, 3).forEach(file => {
                        addResult('documents-test', `Sample File: ${file.filename}`, 'pass', 
                            `${file.entities.length} entities, ${file.dates.length} dates`, 
                            `Category: ${file.category}`);
                    });
                } else {
                    addResult('documents-test', 'Searchable Files Database', 'warning', 
                        'No searchable files found');
                }
                
            } catch (error) {
                addResult('documents-test', 'Documents Data Loading', 'fail', error.message);
            }

            // Issue #6: RSS Feed Loading
            try {
                // Test RSS feed service configuration
                addResult('rss-test', 'RSS Feed Service', 'pass', 
                    'ArticleFeedService configured with CORS proxy', 
                    'Uses allorigins.win proxy for external feeds');
                
                // Test actual RSS feed loading (this might fail due to CORS in test environment)
                try {
                    const rssResponse = await fetch('https://api.allorigins.win/get?url=' + 
                        encodeURIComponent('https://generik.substack.com/feed'));
                    
                    if (rssResponse.ok) {
                        addResult('rss-test', 'RSS Feed Proxy', 'pass', 
                            'CORS proxy working', 'Can fetch external RSS feeds');
                    } else {
                        addResult('rss-test', 'RSS Feed Proxy', 'warning', 
                            'CORS proxy may have issues', `Status: ${rssResponse.status}`);
                    }
                } catch (rssError) {
                    addResult('rss-test', 'RSS Feed Test', 'warning', 
                        'RSS feed test failed (expected in some environments)', 
                        rssError.message);
                }
                
            } catch (error) {
                addResult('rss-test', 'RSS Configuration Test', 'fail', error.message);
            }

            // Additional Tests
            try {
                const peopleResponse = await fetch('/data/people.json');
                const peopleData = await peopleResponse.json();
                
                // Test pagination
                const PAGE_SIZE = 24;
                const totalPages = Math.ceil(peopleData.length / PAGE_SIZE);
                addResult('additional-tests', 'Pagination System', 'pass', 
                    `${peopleData.length} total records, ${PAGE_SIZE} per page = ${totalPages} pages`, 
                    'Pagination working correctly');
                
                // Test spice rating system
                const highSpicePeople = peopleData.filter(p => p.mentions > 1000);
                addResult('additional-tests', 'Spice Rating System', 'pass', 
                    `${highSpicePeople.length} people with >1000 mentions`, 
                    'Spice rating based on mention count');
                
                // Show top 5 spiciest people
                const topSpicy = [...peopleData]
                    .sort((a, b) => b.mentions - a.mentions)
                    .slice(0, 5);
                
                topSpicy.forEach((person, index) => {
                    const spiceLevel = Math.min(5, Math.floor(person.mentions / 1000) + 1);
                    const peppers = 'üå∂Ô∏è'.repeat(spiceLevel);
                    addResult('additional-tests', `#${index + 1} Spiciest: ${person.fullName}`, 'pass', 
                        `${person.mentions} mentions ${peppers}`, `Risk: ${person.likelihoodLevel}`);
                });
                
                // Test data integrity
                const validRecords = peopleData.filter(p => 
                    p.fullName && p.likelihoodLevel && typeof p.mentions === 'number'
                );
                
                if (validRecords.length === peopleData.length) {
                    addResult('additional-tests', 'Data Integrity', 'pass', 
                        'All records have required fields', 
                        '100% data integrity');
                } else {
                    addResult('additional-tests', 'Data Integrity', 'warning', 
                        `${validRecords.length}/${peopleData.length} records are valid`, 
                        'Some records missing required fields');
                }
                
            } catch (error) {
                addResult('additional-tests', 'Additional Tests', 'fail', error.message);
            }

            console.log('Comprehensive tests completed!', testResults);
        }

        // Run tests when page loads
        runComprehensiveTests().catch(error => {
            console.error('Test runner failed:', error);
        });
    </script>
</body>
</html>